#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: Canonical Ltd.
"""
Analyze spread test logs and report execution times for each test.

This script parses spread log output and calculates the time spent in each phase
(Preparing, Executing, Restoring) for each test, then displays a sorted summary.
"""

import re
import sys
from datetime import datetime
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass, field


@dataclass
class TestPhase:
    """Represents a single phase of test execution."""
    name: str
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    
    @property
    def duration(self) -> float:
        """Return duration in seconds."""
        if self.start_time and self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0.0


@dataclass
class TestExecution:
    """Represents a complete test execution with all phases."""
    test_name: str
    system: str
    phases: Dict[str, TestPhase] = field(default_factory=dict)
    
    @property
    def total_duration(self) -> float:
        """Return total duration across all phases in seconds."""
        return sum(phase.duration for phase in self.phases.values())
    
    @property
    def prepare_duration(self) -> float:
        """Return time spent preparing in seconds."""
        return self.phases.get('Preparing', TestPhase('Preparing')).duration
    
    @property
    def execute_duration(self) -> float:
        """Return time spent executing in seconds."""
        return self.phases.get('Executing', TestPhase('Executing')).duration
    
    @property
    def restore_duration(self) -> float:
        """Return time spent restoring in seconds."""
        return self.phases.get('Restoring', TestPhase('Restoring')).duration
    
    @property
    def debug_duration(self) -> float:
        """Return time spent debugging in seconds."""
        return self.phases.get('Debugging', TestPhase('Debugging')).duration


def parse_timestamp(line: str) -> Optional[datetime]:
    """Extract and parse timestamp from a log line."""
    match = re.match(r'^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})', line)
    if match:
        return datetime.strptime(match.group(1), '%Y-%m-%d %H:%M:%S')
    return None


def parse_log_line(line: str) -> Optional[Tuple[datetime, str, str, str]]:
    """
    Parse a spread log line and extract timestamp, phase, system, and test name.
    
    Returns: (timestamp, phase, system, test_name) or None
    """
    timestamp = parse_timestamp(line)
    if not timestamp:
        return None
    
    # Match lines like: "2026-01-13 11:15:15 Preparing garden:archlinux-cloud:tests/desktop/firefox (garden:archlinux-cloud)..."
    # or: "2026-01-13 11:16:13 Executing garden:archlinux-cloud:tests/desktop/firefox (garden:archlinux-cloud) (2/19)..."
    # Note: We specifically look for :tests/ to distinguish test phases from system preparation
    #
    # Test phases execute sequentially in this order:
    # 1. Preparing - setup phase
    # 2. Executing - test execution
    # 3. Restoring - cleanup phase
    # 4. Debugging - only runs if test fails (optional)
    #
    # Pattern breakdown:
    # Group 1: (\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) - timestamp (already extracted above, but included in pattern)
    # Group 2: (Preparing|Executing|Restoring|Debugging) - phase name (sequential phases)
    # Group 3: ([^:]+) - backend (e.g., "garden") - not currently used but available for future enhancements
    # Group 4: ([^:]+) - system name (e.g., "archlinux-cloud")
    # Group 5: (tests/.*?) - test path (e.g., "tests/desktop/firefox" or "tests/server/maas:3_6")
    # Group 6: \(([^)]+)\) - system identifier in parentheses - not currently used
    pattern = r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\s+(Preparing|Executing|Restoring|Debugging)\s+([^:]+):([^:]+):(tests/.*?)\s+\(([^)]+)\)'
    match = re.match(pattern, line)
    
    if match:
        phase = match.group(2)
        # backend = match.group(3)  # Not currently used
        system = match.group(4)
        test_name = match.group(5)
        
        return (timestamp, phase, system, test_name)
    
    return None


def analyze_logs(log_content: str) -> List[TestExecution]:
    """
    Analyze spread log content and extract test execution information.
    
    Tests execute sequentially through phases (Preparing → Executing → Restoring → Debugging).
    When tests run with multiple workers, they can execute concurrently, but each individual
    test still progresses through its phases sequentially.
    
    For sequential execution (workers=1), a test's last phase ends when any subsequent
    test phase begins.
    
    Args:
        log_content: The content of the spread log file
        
    Returns:
        List of TestExecution objects with timing information
    """
    tests: Dict[str, TestExecution] = {}
    lines = log_content.strip().split('\n')
    
    # First pass: collect all log entries with their timestamps
    log_entries = []
    for line in lines:
        parsed = parse_log_line(line)
        if parsed:
            log_entries.append(parsed)
    
    # Second pass: process entries and calculate durations
    # Group entries by test to handle concurrent execution
    # Note: If a test is retried (same phase appears multiple times), only the last occurrence
    # will be recorded. This is acceptable for typical smoke test runs where tests run once.
    test_phases_sequence: Dict[str, List[Tuple[int, datetime, str]]] = {}
    
    for idx, (timestamp, phase, system, test_name) in enumerate(log_entries):
        test_key = f"{system}:{test_name}"
        
        if test_key not in test_phases_sequence:
            test_phases_sequence[test_key] = []
        
        # Store the index in the global log_entries list along with phase info
        test_phases_sequence[test_key].append((idx, timestamp, phase))
    
    # Third pass: calculate durations for each test
    for test_key, phase_sequence in test_phases_sequence.items():
        # Extract system and test_name from test_key
        # test_key format is "system:test_name" where test_name may contain colons
        # (e.g., "archlinux-cloud:tests/server/maas:3_6")
        # Split only on the first colon
        parts = test_key.split(':', 1)
        if len(parts) != 2:
            # Skip malformed test keys
            continue
        system, test_name = parts
        
        test = TestExecution(test_name=test_name, system=system)
        
        # Process each phase in sequence
        # Note: If the same phase appears multiple times (e.g., due to retries), we keep
        # the last occurrence. For typical smoke tests where each test runs once, this is
        # not an issue.
        for i, (global_idx, timestamp, phase) in enumerate(phase_sequence):
            if phase not in test.phases:
                test.phases[phase] = TestPhase(name=phase, start_time=timestamp)
            else:
                # Phase appearing again (retry) - update start time
                test.phases[phase].start_time = timestamp
                test.phases[phase].end_time = None
            
            # Find the end time for this phase
            end_time = None
            
            # First, try to find the next phase for this same test
            if i + 1 < len(phase_sequence):
                _, next_timestamp, _ = phase_sequence[i + 1]
                end_time = next_timestamp
            else:
                # This is the last phase for this test
                # For sequential execution, look for the next log entry from ANY test
                if global_idx + 1 < len(log_entries):
                    next_entry_timestamp, _, _, _ = log_entries[global_idx + 1]
                    end_time = next_entry_timestamp
            
            test.phases[phase].end_time = end_time
        
        tests[test_key] = test
    
    return list(tests.values())


def format_duration(seconds: float) -> str:
    """Format duration in seconds to a human-readable string."""
    if seconds < 60:
        return f"{seconds:.1f}s"
    elif seconds < 3600:
        minutes = int(seconds // 60)
        secs = seconds % 60
        return f"{minutes}m {secs:.1f}s"
    else:
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = seconds % 60
        return f"{hours}h {minutes}m {secs:.1f}s"


def print_summary(tests: List[TestExecution], sort_by: str = 'total'):
    """
    Print a summary of test execution times.
    
    Args:
        tests: List of TestExecution objects
        sort_by: Sort key ('total', 'prepare', 'execute', 'restore')
    """
    if not tests:
        print("No test execution data found in logs.")
        return
    
    # Sort tests by the specified criterion
    sort_key_map = {
        'total': lambda t: t.total_duration,
        'prepare': lambda t: t.prepare_duration,
        'execute': lambda t: t.execute_duration,
        'restore': lambda t: t.restore_duration,
        'debug': lambda t: t.debug_duration,
    }
    
    sort_key = sort_key_map.get(sort_by, sort_key_map['total'])
    sorted_tests = sorted(tests, key=sort_key, reverse=True)
    
    # Calculate total time for completed phases only
    total_time = sum(test.total_duration for test in tests)
    
    # Count incomplete tests
    incomplete_tests = sum(1 for test in tests 
                          if any(phase.end_time is None for phase in test.phases.values()))
    
    # Print header
    print("=" * 122)
    print("Spread Test Execution Time Analysis")
    print("=" * 122)
    print(f"\nTotal tests analyzed: {len(tests)}")
    if incomplete_tests > 0:
        print(f"Incomplete tests (missing end times): {incomplete_tests}")
    print(f"Total execution time (completed phases): {format_duration(total_time)}")
    print(f"\nSorted by: {sort_by} time (descending)\n")
    
    # Print table header
    print(f"{'Test Name':<50} {'System':<20} {'Prepare':>12} {'Execute':>12} {'Restore':>12} {'Debug':>12} {'Total':>12}")
    print("-" * 122)
    
    # Print test data
    for test in sorted_tests:
        test_display = test.test_name[:47] + "..." if len(test.test_name) > 50 else test.test_name
        system_display = test.system[:17] + "..." if len(test.system) > 20 else test.system
        
        # Format phase durations, marking incomplete with * and missing with -
        prepare_str = "-"
        if 'Preparing' in test.phases:
            prepare_str = format_duration(test.prepare_duration)
            if test.phases['Preparing'].end_time is None:
                prepare_str += "*"
            
        execute_str = "-"
        if 'Executing' in test.phases:
            execute_str = format_duration(test.execute_duration)
            if test.phases['Executing'].end_time is None:
                execute_str += "*"
            
        restore_str = "-"
        if 'Restoring' in test.phases:
            restore_str = format_duration(test.restore_duration)
            if test.phases['Restoring'].end_time is None:
                restore_str += "*"
        
        debug_str = "-"
        if 'Debugging' in test.phases:
            debug_str = format_duration(test.debug_duration)
            if test.phases['Debugging'].end_time is None:
                debug_str += "*"
        
        total_str = format_duration(test.total_duration)
        # Mark total as incomplete if any phase is incomplete
        if any(phase.end_time is None for phase in test.phases.values()):
            total_str += "*"
        
        print(f"{test_display:<50} {system_display:<20} "
              f"{prepare_str:>12} "
              f"{execute_str:>12} "
              f"{restore_str:>12} "
              f"{debug_str:>12} "
              f"{total_str:>12}")
    
    print("-" * 122)
    print(f"{'TOTAL (completed phases)':<70} {'':<12} {'':<12} {'':<12} {'':<12} {format_duration(total_time):>12}")
    if incomplete_tests > 0:
        print("\n* = Phase incomplete (no end time in log)")
        print("- = Phase not started or not logged")
    print()


def main():
    """Main entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Analyze spread test logs and report execution times.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Analyze a single log file
  analyze-spread-logs spread.log

  # Analyze log from stdin
  spread -v ubuntu-cloud-24.04 | analyze-spread-logs

  # Sort by execution time only
  analyze-spread-logs spread.log --sort-by execute

  # Analyze multiple log files
  cat spread-logs/*.log | analyze-spread-logs
        """
    )
    
    parser.add_argument(
        'logfile',
        nargs='?',
        default='-',
        help='Path to spread log file (default: stdin)'
    )
    
    parser.add_argument(
        '--sort-by',
        choices=['total', 'prepare', 'execute', 'restore', 'debug'],
        default='total',
        help='Sort tests by phase time (default: total)'
    )
    
    args = parser.parse_args()
    
    # Read log content
    if args.logfile == '-':
        log_content = sys.stdin.read()
    else:
        try:
            with open(args.logfile, 'r') as f:
                log_content = f.read()
        except FileNotFoundError:
            print(f"Error: Log file '{args.logfile}' not found.", file=sys.stderr)
            sys.exit(1)
        except IOError as e:
            print(f"Error reading log file: {e}", file=sys.stderr)
            sys.exit(1)
    
    # Analyze logs
    tests = analyze_logs(log_content)
    
    # Print summary
    print_summary(tests, sort_by=args.sort_by)


if __name__ == '__main__':
    main()
